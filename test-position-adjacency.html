<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŸºäºä½ç½®çš„é‚»æ¥å…³ç³»ç³»ç»Ÿæµ‹è¯•</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            background-color: #f5f5f5; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
        }
        h1, h2 { color: #333; }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fafafa;
        }
        .success { color: #28a745; }
        .error { color: #dc3545; }
        .warning { color: #ffc107; }
        pre {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0056b3; }
        .grid {
            display: grid;
            grid-template-columns: repeat(4, 40px);
            gap: 2px;
            margin: 10px 0;
        }
        .cell {
            width: 40px;
            height: 40px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        .face { background-color: #e3f2fd; }
        .empty { background-color: #fafafa; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ åŸºäºä½ç½®çš„é‚»æ¥å…³ç³»ç³»ç»Ÿæµ‹è¯•</h1>
        
        <div class="test-section">
            <h2>1. ç³»ç»Ÿåˆå§‹åŒ–æµ‹è¯•</h2>
            <button onclick="testSystemInitialization()">è¿è¡Œåˆå§‹åŒ–æµ‹è¯•</button>
            <div id="initResults"></div>
        </div>

        <div class="test-section">
            <h2>2. ä½ç½®é‚»æ¥å…³ç³»æµ‹è¯•</h2>
            <button onclick="testPositionAdjacency()">è¿è¡Œä½ç½®é‚»æ¥æµ‹è¯•</button>
            <div id="positionResults"></div>
        </div>

        <div class="test-section">
            <h2>3. å±•å¼€å›¾ç”Ÿæˆæµ‹è¯•</h2>
            <button onclick="testNetGeneration()">ç”Ÿæˆå¹¶æµ‹è¯•å±•å¼€å›¾</button>
            <div id="netDisplay"></div>
            <div id="netResults"></div>
        </div>

        <div class="test-section">
            <h2>4. ç«‹æ–¹ä½“éªŒè¯æµ‹è¯•</h2>
            <button onclick="testCubeValidation()">è¿è¡Œç«‹æ–¹ä½“éªŒè¯æµ‹è¯•</button>
            <div id="cubeResults"></div>
        </div>

        <div class="test-section">
            <h2>5. å…¼å®¹æ€§æµ‹è¯•</h2>
            <button onclick="testBackwardsCompatibility()">è¿è¡Œå‘åå…¼å®¹æ€§æµ‹è¯•</button>
            <div id="compatibilityResults"></div>
        </div>
    </div>

    <script src="js/adjacency.js"></script>
    <script src="js/cube.js"></script>
    <script>
        let testResults = {
            passed: 0,
            failed: 0,
            total: 0
        };

        function logTest(name, passed, details = '') {
            testResults.total++;
            if (passed) {
                testResults.passed++;
                console.log(`âœ… ${name}: ${details}`);
                return `<div class="success">âœ… ${name}: ${details}</div>`;
            } else {
                testResults.failed++;
                console.log(`âŒ ${name}: ${details}`);
                return `<div class="error">âŒ ${name}: ${details}</div>`;
            }
        }

        function testSystemInitialization() {
            const results = document.getElementById('initResults');
            let html = '<h3>ç³»ç»Ÿåˆå§‹åŒ–æµ‹è¯•ç»“æœ:</h3>';
            
            // æµ‹è¯•å‡½æ•°æ˜¯å¦å­˜åœ¨
            html += logTest('adjacency.js åŠ è½½', typeof setAdjacencyForNet === 'function', 'åŸºç¡€å‡½æ•°å¯ç”¨');
            html += logTest('cube.js åŠ è½½', typeof generateRandomNet === 'function', 'ç«‹æ–¹ä½“å‡½æ•°å¯ç”¨');
            html += logTest('ä½ç½®é‚»æ¥å‡½æ•°', typeof isPositionAdjacent === 'function', 'æ–°çš„ä½ç½®åŸºç¡€å‡½æ•°å¯ç”¨');
            html += logTest('å‘åå…¼å®¹å‡½æ•°', typeof isAdjacent === 'function', 'å…¼å®¹æ€§å‡½æ•°å¯ç”¨');
            
            // æµ‹è¯•é‚»æ¥å…³ç³»è¡¨
            const netTypes = ['åå­—å½¢', 'Tå½¢', 'Zå½¢', 'Lå½¢'];
            for (const netType of netTypes) {
                try {
                    setAdjacencyForNet(netType);
                    const adjacency = getCurrentAdjacency();
                    const hasValidStructure = adjacency && Object.keys(adjacency).length === 6;
                    html += logTest(`${netType} é‚»æ¥å…³ç³»`, hasValidStructure, 
                        hasValidStructure ? 'ç»“æ„æ­£ç¡®' : 'ç»“æ„å¼‚å¸¸');
                } catch (error) {
                    html += logTest(`${netType} é‚»æ¥å…³ç³»`, false, error.message);
                }
            }
            
            results.innerHTML = html;
        }

        function testPositionAdjacency() {
            const results = document.getElementById('positionResults');
            let html = '<h3>ä½ç½®é‚»æ¥å…³ç³»æµ‹è¯•ç»“æœ:</h3>';
            
            // ä¸ºæ¯ç§å±•å¼€å›¾æµ‹è¯•ä½ç½®é‚»æ¥å…³ç³»
            const netTypes = ['åå­—å½¢', 'Tå½¢', 'Zå½¢', 'Lå½¢'];
            
            for (const netType of netTypes) {
                setAdjacencyForNet(netType);
                html += `<h4>${netType} å±•å¼€å›¾æµ‹è¯•:</h4>`;
                
                // æµ‹è¯•å¯¹ç§°æ€§
                let symmetryPassed = true;
                for (let pos1 = 0; pos1 <= 5; pos1++) {
                    for (let pos2 = 0; pos2 <= 5; pos2++) {
                        if (isPositionAdjacent(pos1, pos2) !== isPositionAdjacent(pos2, pos1)) {
                            symmetryPassed = false;
                            break;
                        }
                    }
                    if (!symmetryPassed) break;
                }
                html += logTest(`${netType} å¯¹ç§°æ€§`, symmetryPassed, 'é‚»æ¥å…³ç³»åŒå‘ä¸€è‡´');
                
                // æµ‹è¯•æ¯ä¸ªä½ç½®çš„é‚»æ¥æ•°é‡
                let countPassed = true;
                for (let pos = 0; pos <= 5; pos++) {
                    const adjacent = getAdjacentPositions(pos);
                    if (adjacent.length !== 4) {
                        countPassed = false;
                        break;
                    }
                }
                html += logTest(`${netType} é‚»æ¥æ•°é‡`, countPassed, 'æ¯ä¸ªä½ç½®éƒ½æœ‰4ä¸ªé‚»æ¥ä½ç½®');
            }
            
            results.innerHTML = html;
        }

        function displayNet(net) {
            const maxRow = Math.max(...net.faces.map(f => f.row));
            const maxCol = Math.max(...net.faces.map(f => f.col));
            
            let html = `<h4>${net.name} å±•å¼€å›¾:</h4>`;
            html += '<div style="font-family: monospace; margin: 10px 0;">';
            
            for (let row = 0; row <= maxRow; row++) {
                for (let col = 0; col <= maxCol; col++) {
                    const face = net.faces.find(f => f.row === row && f.col === col);
                    if (face) {
                        html += `[${face.number}] `;
                    } else {
                        html += '   ';
                    }
                }
                html += '<br>';
            }
            html += '</div>';
            
            // æ˜¾ç¤ºé¢çš„ä½ç½®æ˜ å°„
            html += '<p>ä½ç½®ç´¢å¼•æ˜ å°„: ';
            net.faces.forEach((face, index) => {
                html += `ä½ç½®${index}â†’æ•°å­—${face.number} `;
            });
            html += '</p>';
            
            return html;
        }

        function testNetGeneration() {
            const netDisplay = document.getElementById('netDisplay');
            const results = document.getElementById('netResults');
            let html = '<h3>å±•å¼€å›¾ç”Ÿæˆæµ‹è¯•ç»“æœ:</h3>';
            
            try {
                // ç”Ÿæˆä¸€ä¸ªéšæœºå±•å¼€å›¾
                const net = generateRandomNet();
                
                // æ˜¾ç¤ºå±•å¼€å›¾
                netDisplay.innerHTML = displayNet(net);
                
                // æµ‹è¯•å±•å¼€å›¾çš„åŸºæœ¬å±æ€§
                html += logTest('å±•å¼€å›¾ç”Ÿæˆ', net !== null, 'æˆåŠŸç”Ÿæˆå±•å¼€å›¾');
                html += logTest('é¢æ•°æ­£ç¡®', net.faces && net.faces.length === 6, 'åŒ…å«6ä¸ªé¢');
                html += logTest('æ•°å­—å”¯ä¸€', new Set(net.faces.map(f => f.number)).size === 6, 'æ•°å­—1-6å„å‡ºç°ä¸€æ¬¡');
                
                // æµ‹è¯•é‚»æ¥å…³ç³»æ˜¯å¦æ­£ç¡®è®¾ç½®
                const currentType = getCurrentNetType();
                html += logTest('é‚»æ¥å…³ç³»è®¾ç½®', currentType === net.name, `å½“å‰ç±»å‹: ${currentType}`);
                
                // æµ‹è¯•åŸºäºä½ç½®çš„é‚»æ¥å…³ç³»
                let adjacencyWorks = true;
                try {
                    for (let i = 0; i < 6; i++) {
                        for (let j = i + 1; j < 6; j++) {
                            const isAdj = isPositionAdjacent(i, j);
                            // åªè¦ä¸æŠ›é”™è¯¯å°±ç®—æˆåŠŸ
                        }
                    }
                } catch (error) {
                    adjacencyWorks = false;
                }
                html += logTest('ä½ç½®é‚»æ¥æŸ¥è¯¢', adjacencyWorks, 'ä½ç½®é‚»æ¥å…³ç³»å¯æ­£å¸¸æŸ¥è¯¢');
                
            } catch (error) {
                html += logTest('å±•å¼€å›¾ç”Ÿæˆ', false, error.message);
            }
            
            results.innerHTML = html;
        }

        function testCubeValidation() {
            const results = document.getElementById('cubeResults');
            let html = '<h3>ç«‹æ–¹ä½“éªŒè¯æµ‹è¯•ç»“æœ:</h3>';
            
            try {
                // ç”Ÿæˆå±•å¼€å›¾
                const net = generateRandomNet();
                
                // æµ‹è¯•æ­£ç¡®ç«‹æ–¹ä½“ç”Ÿæˆ
                const correctCube = generateCorrectCube(net);
                html += logTest('æ­£ç¡®ç«‹æ–¹ä½“ç”Ÿæˆ', correctCube !== null, 
                    `å‰é¢:${correctCube.front}, å·¦é¢:${correctCube.left}, ä¸Šé¢:${correctCube.top}`);
                
                // æµ‹è¯•ç«‹æ–¹ä½“éªŒè¯å‡½æ•°
                const isValid = isValidCubeFaces(correctCube, net);
                html += logTest('ç«‹æ–¹ä½“éªŒè¯', isValid, 'ç”Ÿæˆçš„ç«‹æ–¹ä½“é€šè¿‡éªŒè¯');
                
                // æµ‹è¯•ä¸€äº›æ— æ•ˆç»„åˆ
                const invalidCube1 = {front: 1, left: 1, top: 2}; // é‡å¤é¢
                const invalid1 = isValidCubeFaces(invalidCube1, net);
                html += logTest('é‡å¤é¢æ£€æµ‹', !invalid1, 'æ­£ç¡®æ‹’ç»é‡å¤é¢');
                
                // æµ‹è¯•å¤šæ¬¡ç”Ÿæˆçš„ä¸€è‡´æ€§
                let consistencyPassed = true;
                for (let i = 0; i < 5; i++) {
                    const testNet = generateRandomNet();
                    const testCube = generateCorrectCube(testNet);
                    if (!isValidCubeFaces(testCube, testNet)) {
                        consistencyPassed = false;
                        break;
                    }
                }
                html += logTest('ç”Ÿæˆä¸€è‡´æ€§', consistencyPassed, 'å¤šæ¬¡ç”Ÿæˆéƒ½èƒ½é€šè¿‡éªŒè¯');
                
            } catch (error) {
                html += logTest('ç«‹æ–¹ä½“éªŒè¯æµ‹è¯•', false, error.message);
            }
            
            results.innerHTML = html;
        }

        function testBackwardsCompatibility() {
            const results = document.getElementById('compatibilityResults');
            let html = '<h3>å‘åå…¼å®¹æ€§æµ‹è¯•ç»“æœ:</h3>';
            
            try {
                // ç”Ÿæˆå±•å¼€å›¾
                const net = generateRandomNet();
                
                // æµ‹è¯•æ—§ç‰ˆisAdjacentå‡½æ•°
                const face1 = net.faces[0].number;
                const face2 = net.faces[1].number;
                
                // ä½¿ç”¨æ–°çš„åŸºäºä½ç½®çš„æ–¹æ³•
                const newResult = isAdjacent(face1, face2, net.faces);
                html += logTest('æ–°ç‰ˆisAdjacent', typeof newResult === 'boolean', 'å‡½æ•°æ­£å¸¸è¿”å›å¸ƒå°”å€¼');
                
                // ä½¿ç”¨ä¼ ç»Ÿçš„åŸºäºæ•°å­—çš„æ–¹æ³•
                const oldResult = isAdjacentByNumber(face1, face2);
                html += logTest('ä¼ ç»ŸisAdjacentByNumber', typeof oldResult === 'boolean', 'å…¼å®¹æ€§å‡½æ•°æ­£å¸¸å·¥ä½œ');
                
                // æµ‹è¯•getAdjacentFaceså‡½æ•°
                const adjacentFaces = getAdjacentFaces(face1, net.faces);
                html += logTest('getAdjacentFaces', Array.isArray(adjacentFaces), `è¿”å›${adjacentFaces.length}ä¸ªé‚»æ¥é¢`);
                
                // æµ‹è¯•canMeetAtVertexå‡½æ•°
                const canMeet = canMeetAtVertex(1, 2, 3, net.faces);
                html += logTest('canMeetAtVertex', typeof canMeet === 'boolean', 'é¡¶ç‚¹ç›¸é‡æ£€æµ‹æ­£å¸¸');
                
            } catch (error) {
                html += logTest('å‘åå…¼å®¹æ€§æµ‹è¯•', false, error.message);
            }
            
            results.innerHTML = html;
        }

        // é¡µé¢åŠ è½½å®Œæˆåè¿è¡ŒåŸºç¡€æµ‹è¯•
        window.addEventListener('load', () => {
            console.log('ğŸš€ åŸºäºä½ç½®çš„é‚»æ¥å…³ç³»ç³»ç»Ÿæµ‹è¯•é¡µé¢å·²åŠ è½½');
        });
    </script>
</body>
</html>